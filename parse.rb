#!/usr/bin/env ruby

require 'rubygems'
require 'mechanize'
require 'builder'

# House Hansard for 20 September 2007
url = "http://parlinfoweb.aph.gov.au/piweb/browse.aspx?path=Chamber%20%3E%20House%20Hansard%20%3E%202007%20%3E%2020%20September%202007"
date = "2007-09-20"

# Required to workaround long viewstates generated by .NET (whatever that means)
# See http://code.whytheluckystiff.net/hpricot/ticket/13
Hpricot.buffer_size = 262144

agent = WWW::Mechanize.new
page = agent.get(url)

xml_filename = "pwdata/scrapedxml/debates/debates#{date}.xml"
xml = File.open(xml_filename, 'w')
x = Builder::XmlMarkup.new(:target => xml, :indent => 1)

title = ""
subtitle = ""

# Generates unique identifier for each piece of text in the Hansard
class Id
  def initialize(date)
    @date = date
    @count = 0
  end
  
  def to_s
    @count = @count + 1
 	  "uk.org.publicwhip/debate/#{@date}.#{@count}"
  end
end

id = Id.new(date)

x.instruct!
x.publicwhip do
  # Structure of the page is such that we are only interested in some of the links
  for link in page.links[30..50] do
  #for link in page.links[30..-3] do
    puts "Processing: #{link}"
  	# Only going to consider speeches for the time being
  	if link.to_s =~ /Speech:/
    	# Link text for speech has format:
    	# HEADING > NAME > HOUR:MINS:SECS
    	split = link.to_s.split('>').map{|a| a.strip}
    	puts "Warning: Expected split to have length 3" unless split.size == 3
    	time = split[2]
    	# Reverse order of name
    	speaker_first_name = split[1].split(',')[1].strip
    	speaker_last_name = split[1].split(',')[0].strip
    	speakername = speaker_first_name + " " + speaker_last_name
     	sub_page = agent.click(link)
     	# Extract permanent URL of this subpage
     	url = sub_page.links.text("[Permalink]").uri.to_s
    	# Type of page. Possible values: No, Speech, Bills
    	type = sub_page.search('//span[@id=dlMetadata__ctl7_Label3]/*').to_s
    	puts "Warning: Expected type Speech but was type #{type}" unless type == "Speech"
    	content = sub_page.search('//div#contentstart/*')
     	# Top level div classes in content
     	#puts content
     	#puts content.search('/')
     	#content.search('/').each do |e|
     	#  puts "Top level attribute: " + e.outer_html.attributes['class']
   	  #end
   	  newtitle = content.search('//div[@class=hansardtitle]').inner_html
   	  newsubtitle = content.search('//div[@class=hansardsubtitle]').inner_html
   	  # Only add headings if they have changed
   	  if newtitle != title
     	  x.tag!("major-heading", newtitle, :id => id, :url => url)
      end
   	  if newtitle != title || newsubtitle != subtitle
     	  x.tag!("minor-heading", newsubtitle, :id => id, :url => url)
      end
      title = newtitle
      subtitle = newsubtitle 	      
  	  x.speech(:speakername => speakername, :time => time, :url => url, :id => id) { x << content.to_s }
    end
  end
end

xml.close

# Temporary hack: fix encoding problems so it's valid XML
system("tidy -indent -xml -modify #{xml_filename}")

# And load up the database
system("/Users/matthewl/twfy/cvs/mysociety/twfy/scripts/xml2db.pl --debates --all --force")