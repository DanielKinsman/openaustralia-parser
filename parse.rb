#!/usr/bin/env ruby

require 'rubygems'
require 'mechanize'
require 'builder'

# My bits and bobs
require 'id'

# First load all-members.xml back in so that we can look up member id's
doc = Hpricot(open("pwdata/members/all-members.xml"))
members = doc.search('member').map{|m| m.attributes}

# House Hansard for 20 September 2007
url = "http://parlinfoweb.aph.gov.au/piweb/browse.aspx?path=Chamber%20%3E%20House%20Hansard%20%3E%202007%20%3E%2020%20September%202007"
date = "2007-09-20"

# Required to workaround long viewstates generated by .NET (whatever that means)
# See http://code.whytheluckystiff.net/hpricot/ticket/13
Hpricot.buffer_size = 262144

agent = WWW::Mechanize.new
page = agent.get(url)

xml_filename = "pwdata/scrapedxml/debates/debates#{date}.xml"
xml = File.open(xml_filename, 'w')
x = Builder::XmlMarkup.new(:target => xml, :indent => 1)

title = ""
subtitle = ""

def quote(text)
  text.sub('&', '&amp;')
end

id = Id.new("uk.org.publicwhip/debate/#{date}.")

x.instruct!

def find_members_by_lastname(lastname, members)
  members.find_all{|m| m["lastname"].downcase == lastname.downcase}
end

# If firstname is empty will just check by lastname
def find_members_by_name(firstname, lastname, members)
  # First checking if there is an unambiguous match by lastname which allows
  # an amount of variation in first name: ie Tony vs Anthony
  matches = find_members_by_lastname(lastname, members)
  if firstname != "" && matches.size > 1
    matches = members.find_all do |m|
      m["firstname"].downcase == firstname.downcase && m["lastname"].downcase == lastname.downcase
    end
  end
  matches
end

def find_member_id_by_name(firstname, lastname, members)
  matches = find_members_by_name(firstname, lastname, members)
  throw "More than one match for member based on first and last name" if matches.size > 1
  throw "No match for member found" if matches.size == 0
  matches[0]["id"]
end

def find_member_id_by_fullname(name, members)
  names = name.split(' ')
  names.delete("Mr")
  names.delete("Mrs")
  names.delete("Ms")
  names.delete("Dr")
  if names.size == 2
    firstname = names[0]
    lastname = names[1]
  elsif names.size == 1
    firstname = ""
    lastname = names[0]
  else
    throw "Can't parse the name #{name}"
  end
  find_member_id_by_name(firstname, lastname, members)
end

# Merges together two or more speeches by the same person that occur consecutively
class SpeechOutputter
  def initialize(x)
    @old_content = Hpricot::Elements.new
    @x = x
  end
  
  def speech(speakername, time, url, id, speakerid, content)
    if speakername != @old_speakername
      if @old_speakername
        p @old_content.to_s
        @x.speech(:speakername => @old_speakername, :time => @old_time, :url => @old_url, :id => @old_id,
          :speakerid => @old_speakerid) { @x << @old_content.to_s }
      end
      @old_speakername = speakername
      @old_time = time
      @old_url = url
      @old_id = id
      @old_speakerid = speakerid
      @old_content.clear
    end
    if content.kind_of?(Array)
      @old_content = @old_content + content
    else
      @old_content << content
    end
  end
  
  def finish
    @x.speech(:speakername => @old_speakername, :time => @old_time, :url => @old_url, :id => @old_id,
      :speakerid => @old_speakerid) { @x << @old_content.to_s }
  end
end

def speech(speakername, content, x, members, time, url, id, speech_outputter)
  # I'm completely guessing here the meaning of p.paraitalic
  if content[0] && content[0].attributes["class"] == "paraitalic"
    puts "Overriding speaker name"
    p content[0].attributes["class"]
    # Override speaker name
    speakername = "unknown"
  end
  # HACK alert (Oh you know what this whole thing is a big hack alert)
  if speakername.downcase == "the speaker"
    speakername = "Mr David Hawker"
  end
  # Lookup id of member based on speakername
  if speakername.downcase == "the deputy speaker" || speakername.downcase == "unknown"
    speakerid = nil
  else
    speakerid = find_member_id_by_fullname(speakername, members)
  end
  speech_outputter.speech(speakername, time, url, id, speakerid, content)
end

x.publicwhip do
  # Structure of the page is such that we are only interested in some of the links
  for link in page.links[30..-4] do
  #for link in page.links[108..108] do
    puts "Processing: #{link}"
  	# Only going to consider speeches for the time being
  	if link.to_s =~ /Speech:/
    	# Link text for speech has format:
    	# HEADING > NAME > HOUR:MINS:SECS
    	split = link.to_s.split('>').map{|a| a.strip}
    	puts "Warning: Expected split to have length 3" unless split.size == 3
    	time = split[2]
     	sub_page = agent.click(link)
     	# Extract permanent URL of this subpage. Also, quoting because there is a bug
     	# in XML Builder that for some reason is not quoting attributes properly
     	url = quote(sub_page.links.text("[Permalink]").uri.to_s)
    	# Type of page. Possible values: No, Speech, Bills
    	type = sub_page.search('//span[@id=dlMetadata__ctl7_Label3]/*').to_s
    	puts "Warning: Expected type Speech but was type #{type}" unless type == "Speech"
   	  newtitle = sub_page.search('div#contentstart div.hansardtitle').inner_html
   	  newsubtitle = sub_page.search('div#contentstart div.hansardsubtitle').inner_html

   	  # Only add headings if they have changed
   	  if newtitle != title
     	  x.tag!("major-heading", newtitle, :id => id, :url => url)
      end
   	  if newtitle != title || newsubtitle != subtitle
     	  x.tag!("minor-heading", newsubtitle, :id => id, :url => url)
      end
      title = newtitle
      subtitle = newsubtitle
      
      speech_outputter = SpeechOutputter.new(x)
      
      # Untangle speeches from subspeeches
      speech_content = Hpricot::Elements.new
    	content = sub_page.search('div#contentstart > div.speech0 > *')
    	main_speakername = ""
    	content.each do |e|
    	  if e.attributes["class"] == "subspeech0" || e.attributes["class"] == "subspeech1"
          # Extract speaker name from link
          if main_speakername == ""
            main_speakername = speech_content.search('span.talkername a').first.inner_html
          end
    	    speech(main_speakername, speech_content, x, members, time, url, id, speech_outputter)
          # Extract speaker name from link
          if e.search('span.talkername a').first.nil?
              speakername = "unknown"
          else
            speakername = e.search('span.talkername a').first.inner_html
          end
    	    speech(speakername, e, x, members, time, url, id, speech_outputter)
    	    speech_content.clear
    	  else
    	    speech_content << e
  	    end
    	end
      # Extract speaker name from link
      if main_speakername == ""
        main_speakername = speech_content.search('span.talkername a').first.inner_html
      end
	    speech(main_speakername, speech_content, x, members, time, url, id, speech_outputter)
	    speech_outputter.finish    
    end
  end
end

xml.close

# Temporary hack: nicely indent XML
system("tidy -quiet -indent -xml -modify -wrap 0 -utf8 #{xml_filename}")

# And load up the database
system("/Users/matthewl/twfy/cvs/mysociety/twfy/scripts/xml2db.pl --debates --all --force")