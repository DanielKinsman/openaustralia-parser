# Capistrano 2.x recipe file
#
# Requirement cap 2.1

require 'tempfile'

set :application, "openaustralia-app"

# default_run_options[:pty] = true

set :use_sudo, false

set :repository_root, "/Library/WebServer/Documents/openaustralia-app"
set :twfy_repository, "#{repository_root}/twfy"
set :phplib_repository, "#{repository_root}/phplib"
set :perllib_repository, "#{repository_root}/perllib"
set :rblib_repository, "#{repository_root}/rblib"
set :parser_repository, "/Users/matthewl/git/openaustralia-parser"

local_deploy = false

if local_deploy
	set :deploy_to, "/Library/WebServer/Documents/test-deploy/#{application}"
	role :web, "localhost"
	set :user, "matthewl"
else
	set :deploy_to, "/www/openaustralia.org/#{application}"
	role :web, "www-test.openaustralia.org"
	set :user, "matthewl"
end

load 'deploy' if respond_to?(:namespace) # cap2 differentiator

namespace :deploy do
	task :setup do
		dirs = [deploy_to, releases_path, shared_path]
		shared_images_path = File.join(shared_path, "images")
		dirs += ["mps", "mpsL"].map {|d| File.join(shared_images_path, d)}
		run "umask 02 && mkdir -p #{dirs.join(' ')}"
	end

	# Do nothing for deploy:restart
	task :restart do
	end

	task :finalize_update do
		run "chmod -R g+w #{latest_release}" if fetch(:group_writable, true)
	end

	desc "After a code update, we link the images directories to the shared ones"
	task :after_update_code do
		links = {"#{release_path}/twfy/www/docs/images/mps" => "#{shared_path}/images/mps",
			"#{release_path}/twfy/www/docs/images/mpsL" => "#{shared_path}/images/mpsL",
			"#{release_path}/twfy/conf/general" => "#{shared_path}/general",
			"#{release_path}/twfy/www/docs/.htaccess" => "#{shared_path}/root_htaccess"}
		
		run "rm -rf #{links.keys.join(' ')}"
		links.each_pair {|src, dst| run "ln -s #{dst} #{src}"} 
	end
	
	desc "Upload member images from local machine"
	task :images do
		put_directory "../pwdata/images/mps", "#{shared_path}/images/mps"
		put_directory "../pwdata/images/mpsL", "#{shared_path}/images/mpsL"
	end
	
	task :update_code, :except => { :no_release => true } do
		on_rollback { run "rm -rf #{release_path}; true" }
		clone_and_upload(parser_repository, "openaustralia-parser", release_path)
    clone_and_upload(phplib_repository, "phplib", release_path)
    clone_and_upload(perllib_repository, "perllib", release_path)
    clone_and_upload(rblib_repository, "rblib", release_path)
    clone_and_upload(twfy_repository, "twfy", release_path)
		finalize_update
	end

	#desc "Upload local database contents"
	#task :database do
	#	tmpdir = Dir.tmpdir
	#	filename = "#{tmpdir}/twfy-australia.sql"
	#	remote_filename = "/tmp/twfy-australia.sql"
	#	# Dump local database to a temporary file
	#	system("mysqldump5 -u twfy-australia --password=twfy-australia twfy-australia > #{filename}")
	#	put_compressed(filename, remote_filename)
	#	# Load up the database
	#	run "mysql -u db3716_twfy --password=twfy-australia -h internal-db.s3716.gridserver.com db3716_twfy_australia < #{remote_filename}; rm #{remote_filename}"
	#end
end

def clone_and_upload(repository, dir, release_path)
	tmpdir = Dir.tmpdir
	run "mkdir -p #{release_path}"
	system("cd #{tmpdir}; rm -rf #{dir}; git clone #{repository}; rm -rf #{dir}/.git")
	put_directory "#{tmpdir}/#{dir}", "#{release_path}/#{dir}"  
end

def put_compressed(src_file, dst_file)
	src_file_compressed = "#{src_file}.gz"
	dst_file_compressed = "#{dst_file}.gz"
	# Compress
	system("gzip -c #{src_file} > #{src_file_compressed}")
    content = File.open(src_file_compressed, "rb") { |f| f.read }
    put content, dst_file_compressed
	run "gunzip #{dst_file_compressed}"
	system("rm #{src_file_compressed}")
end

def put_directory(source, destination)
	dir = File.basename(source)
	throw "Problem with the destination path" if File.basename(destination) != dir
	src = File.dirname(source)
	dst = File.dirname(destination)
	
	tmpdir = Dir.tmpdir
	filename = "#{tmpdir}/#{dir}.tar.gz"
	remote_filename = "/tmp/#{dir}.tar.gz"
	Dir.chdir(src) do
		system("tar", "czf", filename, "#{dir}")
	end
    content = File.open(filename, "rb") { |f| f.read }
    put content, remote_filename
	# Extract archive on remote machine
	run "cd #{dst}; tar xzf #{remote_filename}; rm #{remote_filename}"
	# Clean up
	system("rm #{filename}")
end
