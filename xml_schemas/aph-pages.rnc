start = element hansard {
	element page {
		start-of-transcript | start-of-business | speech | procedural-text | division | adjournment | question | misc
	}+
}

common-metadata =
	element main-committee { "Yes" | "No" } &
	element size { text } &
	element proof { "Yes" } &
	element source { "House" } &
	element database { "House Hansard" } &
	element date { text } &
	element page { xsd:integer }
	
misc =
	element meta {
		element context { "Bills" | "Miscellaneous" | "Start of Transcript" | "Start of Business" } &
		common-metadata &
		
		# Optional metadata
		element stage { "First Reading" | "Second Reading" | "Third Reading" | "Report from Main Committee" }?
	},
	anyElement

question =
	element meta {
		element type { "Question" } &

		element context { "Questions Without Notice" | "Questions in Writing" } &
		common-metadata &
		element responder { text } &
		element questioner { text } &

		# Optional metadata
		element interjector { text }? &
		element question_no { xsd:integer }?
	},
	anyElement
	
adjournment =
	element meta {
		element type { "Adjournment" } &

		element context { "Adjournment" } &
		common-metadata
	},
	anyElement

division =
	element meta {
		element type { "Division" } &

		element context { "Bills" | "Miscellaneous" } &
		common-metadata &
		
		# Optional metadata
		element stage { "First Reading" | "Second Reading" | "Third Reading" | "Report from Main Committee" }?
	},
	anyElement
	
procedural-text =
	element meta {
		element type { "Procedural text" } &

		element context {
			"Adjournment" | "Notices" | "Matters of Public Importance" | "Miscellaneous" | "Business" | "Bills"
		} &
		common-metadata &
		
		# Optional metadata
		element interjector { text }? &
		element stage { "First Reading" | "Second Reading" | "Third Reading" | "Report from Main Committee" }?
	},
	anyElement

speech =
	element meta {
		element type { "Speech" } &
		
		element context {
			"Miscellaneous" | "Distinguished Visitors" | "Bills" | "Business" | "Ministerial Arrangements" | "Questions Without Notice" |
			"Questions Without Notice: Additional Answers" | "Auditor-General's Reports" | "Statements by Members" | "Adjournment"
		} &
		common-metadata &
		element speaker { text } &

		# Optional metadata
		element interjector { text }? &
		element stage { "First Reading" | "Second Reading" | "Third Reading" | "Report from Main Committee" }?
	},
	element content {
		element div {
			attribute class { "contentstart" },
			attribute id { "contentstart" },
			element div {
				attribute class { "hansardtitlegroup" },
				element div {
					attribute class { "hansardtitle" },
					text
				}+
			},
			element div {
				attribute class { "hansardsubtitlegroup" },
				element div {
					attribute class { "hansardsubtitle" },
					text
				}+
			}?,			
			speech0
		}
	}

speech0-div-motion =
	element div {
		attribute class { "motion" },
		(speech0-p | speech0-p-parablock),
		element dl {
			(element dt { text }, element dd { text })+
		}?
	}

speech0-p-parabold =
	element p {
		attribute class { "parabold" },
		text
	}
	
speech0-p-paraitalic =
	element p {
		attribute class { "paraitalic" },
		text
	}

speech0-p-parablock =
	element p {
		attribute class { "parablock" },
		marked-text
	}

speech0-p-block =
	element p {
		attribute class { "block" },
		marked-text
	}

speech0-div-quote =
	element div {
		attribute class { "quote" },
		(speech0-p-parablock | speech0-p | html-definition-list )+
	}

html-list =
	element ul {
		element li { text }+
	}
	
html-definition-list =
	element dl {
		(element dt { text }, element dd { text })+
	}

speech0-p =
	element p {
		marked-text
	}

speech0-b =
	element b {
		element p { text },
		element hr { empty }
	}

speech0 =
	element div {
		attribute class { "speech0" },
		element div {
			attribute class { "speechType" },
			"Speech"
		},
		element p {
			element span {
				attribute class { "talkername" },
				element a {
					attribute href { text }?,
					text
				}
			},
			marked-text?,
			element span {
				attribute class { "talkerelectorate" },
				text
			}?,
			marked-text?,
			element span {
				attribute class { "talkerrole" },
				text
			}?,
			marked-text
		},
		(speech0-div-motion | speech0-p | speech0-p-parablock | speech0-p-paraitalic | speech0-p-parabold |
		speech0-p-block | speech0-div-quote | speech0-div-subspeech | html-list | speech0-b )*
	}

marked-text =
	element a {
		attribute href { text }?,
		text
	}* &
	element b { text }* &
	element i { text }* &
	text*

speech0-div-subspeech =
	element div {
		attribute class { "subspeech0" | "subspeech1" },
		element div { 
			attribute class { "speechType" },
			("Continue" | "Interjection")
		},
		element p {
			element span {
				attribute class { "talkername" },
				element a {
					attribute href { text }?,
					text
				}
			}?,
			marked-text
		}
	}
	
start-of-transcript =
	element meta {
		element type { "Start of Transcript" } &
		element context { "Start of Transcript" } &
		common-metadata
	},
	element content {
		element div {
			attribute class { "contentstart" },
			attribute id { "contentstart" },
			element div {
				attribute class { "titlepage" },
				element div {
					attribute class { "crest" },
					element img {
						attribute src { text },
						attribute alt { text }
					}
				},
				element div { attribute class { "mainheading" }, text },
				element div { attribute class { "date" }, text },
				element div { attribute class { "sessioninfo" }, text }+,
				element div { attribute class { "authority" }, text },
				element div { attribute class { "proof" }, text }
			}
		}
	}

start-of-business =
	element meta {
		element type { "Start of Business" } &
		element context { "Start of Business" } &
		common-metadata
	},
	element content {
		element div {
			attribute class { "contentstart" },
			attribute id { "contentstart" },
			element div {
				attribute class { "businessStart" },
				element div { attribute class { "bsDate" }, text },
				element div {
					attribute class { "separator" },
					element hr { attribute width { "25%" } }
				}?,
				element p {
					element b { text } &
					text
				}
			}
		}
	}
	
# Matches any well-formed XML
anyElement =
  element * {
    (attribute * { text }
     | text
     | anyElement)*
  }
